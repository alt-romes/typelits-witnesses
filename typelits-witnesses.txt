-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Existential witnesses, singletons, and classes for operations on GHC TypeLits
--   
--   Provides witnesses for <a>KnownNat</a> and <a>KnownSymbol</a>
--   instances for various operations on GHC TypeLits - in particular, the
--   arithmetic operations defined in <a>GHC.TypeLits</a>, and also for
--   type-level lists of <a>KnownNat</a> and <a>KnownSymbol</a> instances.
--   
--   This is useful for situations where you have <tt><a>KnownNat</a>
--   n</tt>, and you want to prove to GHC <tt><a>KnownNat</a> (n + 3)</tt>,
--   or <tt><a>KnownNat</a> (2*n + 4)</tt>.
--   
--   It's also useful for when you want to work with type level lists of
--   <a>KnownNat</a> or <a>KnownSymbol</a> instances and singletons for
--   traversing them, and be able to apply analogies of <a>natVal</a> and
--   <a>symbolVal</a> to lists with analogies for <a>SomeNat</a> and
--   <a>SomeSymbol</a>.
--   
--   See README for more information.
@package typelits-witnesses
@version 0.2.0.0


-- | Provides the <a>KnownNats</a> and <a>KnownSymbols</a> typeclasses in
--   analogy to <a>KnownNat</a> and <a>KnownSymbol</a> from
--   <a>GHC.TypeLits</a>. Also provides singleton-esque structures for
--   traversing over type-level lists of <a>Nat</a>s and <a>Symbol</a>s.
--   Comes with continuation-style reifiers and existential types for
--   dependent typing usage, and as an analogy with <a>SomeNat</a> and
--   <a>SomeSymbol</a>.
--   
--   See typeclass documentations and README for more information.
module GHC.TypeLits.List

-- | <tt><a>KnownNats</a> ns</tt> is intended to represent that every
--   <a>Nat</a> in the type-level list <tt>ns</tt> is itself a
--   <a>KnownNat</a> (meaning, you can use <a>natVal</a> to get its
--   corresponding <a>Integer</a>).
--   
--   In practice, just knowing that every item has a <a>KnownNat</a>
--   instance is not enough; it's nice, but unless you're able to "iterate"
--   over every <a>Nat</a> in the list, it's of limited use. That's why
--   this class also provides a constructor for <tt><a>NatList</a> ns</tt>,
--   so that you can produce a <a>NatList</a> for every <tt><a>KnownNat</a>
--   ns</tt>, which you can iterate over to get <tt><a>Proxy</a> n</tt>s
--   for every <tt>n</tt> in <tt>ns</tt> along with the <tt><a>KnownNat</a>
--   n</tt> instances.
--   
--   It also has an analogy to <a>natVal</a>, <a>natsVal</a>, which lets
--   you get a list of the represented <a>Integer</a>s for, say,
--   <tt><a>Proxy</a> [1,2,3]</tt>.
class KnownNats (ns :: [Nat])
natsVal :: KnownNats ns => p ns -> [Integer]
natsList :: KnownNats ns => NatList ns

-- | Represents unknown type-level lists of type-level natural numbers.
--   It's a <a>NatList</a>, but you don't know what the list contains at
--   compile-time.
data SomeNats :: *
SomeNats :: !(NatList ns) -> SomeNats

-- | Singleton-esque type for "traversing" over type-level lists of
--   <a>Nat</a>s. Essentially contains a (value-level) list of
--   <tt><a>Proxy</a> n</tt>s, but each <tt>n</tt> has a <a>KnownNat</a>
--   instance for you to use. At runtime (after type erasure), is more or
--   less equivalent to a <tt>[<a>Integer</a>]</tt>.
--   
--   Typically generated using <a>natsList</a>.
data NatList :: [Nat] -> *
ØNL :: NatList '[]
(:<#) :: !(Proxy n) -> !(NatList ns) -> NatList (n : ns)

-- | List equivalent of <a>someNatVal</a>. Convert a list of integers into
--   an unknown type-level list of naturals. Will return <a>Nothing</a> if
--   any of the given <a>Integer</a>s is negative.
someNatsVal :: [Integer] -> Maybe SomeNats

-- | Like <a>someNatsVal</a>, but will also go ahead and produce
--   <a>KnownNat</a>s whose integer values are negative. It won't ever
--   error on producing them, but extra care must be taken when using the
--   produced <a>SomeNat</a>s.
someNatsValPos :: [Integer] -> SomeNats

-- | List equivalent of <a>reifyNat</a>. Given a list of integers, takes a
--   function in an "environment" with a <tt><a>NatList</a> ns</tt>
--   corresponding to the given list, where every <tt>n</tt> in <tt>ns</tt>
--   has a <a>KnownNat</a> instance.
--   
--   Essentially a continuation-style version of <a>SomeNats</a>.
--   
--   Be aware that this also produces <tt><a>KnownNat</a> n</tt>s where
--   <tt>n</tt> is negative, without complaining. To be consistent, within
--   the library, this <i>should</i> be called <tt>reifyNatsPos</tt>;
--   however, the naming choice is for consistency with <a>reifyNat</a>
--   from the <i>reflections</i> package. Use <a>reifyNats'</a> for a
--   "safe" version.
reifyNats :: [Integer] -> (forall ns. KnownNats ns => NatList ns -> r) -> r

-- | <a>Safe</a> version of <a>reifyNats</a>, which will only run the
--   continuation if every <a>Integer</a> in the list is non-negative. If
--   not, then returns the given "default" value instead.
reifyNats' :: [Integer] -> r -> (forall ns. KnownNats ns => NatList ns -> r) -> r

-- | Get evidence that the two <a>KnownNats</a> lists are actually the
--   "same" list of <a>Nat</a>s (that they were instantiated with the same
--   numbers).
--   
--   Essentialy runs <a>sameNat</a> over the lists:
--   
--   <pre>
--   case <a>sameNats</a> ns ms of
--     Just <a>Refl</a> -&gt; -- in this branch, GHC recognizes that the two [<a>Nat</a>]s
--                    -- are the same.
--     Nothing   -&gt; -- in this branch, they aren't
--   </pre>
sameNats :: (KnownNats ns, KnownNats ms) => NatList ns -> NatList ms -> Maybe (ns :~: ms)

-- | Utility function for traversing over all of the <tt><a>Proxy</a>
--   n</tt>s in a <a>NatList</a>, each with the corresponding
--   <a>KnownNat</a> instance available. Gives the the ability to "change"
--   the represented natural number to a new one, in a <a>SomeNat</a>.
--   
--   Can be considered a form of a <tt>Traversal' <a>SomeNat</a>
--   <a>SomeNats</a></tt>.
traverseNatList :: Applicative f => (forall n. KnownNat n => Proxy n -> f SomeNat) -> NatList ns -> f SomeNats

-- | Like <a>traverseNatList</a>, but literally actually a <tt>Traversal'
--   <a>SomeNat</a> <a>SomeNats</a></tt>, avoiding the Rank-2 types, so is
--   usable with lens-library machinery.
traverseNatList' :: Applicative f => (SomeNat -> f SomeNat) -> SomeNats -> f SomeNats

-- | Utility function for traversing over all of the <tt><a>Proxy</a>
--   n</tt>s in a <a>NatList</a>, each with the corresponding
--   <a>KnownNat</a> instance available. Results are ignored.
traverseNatList_ :: Applicative f => (forall n. KnownNat n => Proxy n -> f a) -> NatList ns -> f ()

-- | Utility function for "mapping" over each of the <a>Nat</a>s in the
--   <a>NatList</a>.
mapNatList :: (forall n. KnownNat n => Proxy n -> SomeNat) -> NatList ns -> SomeNats

-- | Like <a>mapNatList</a>, but avoids the Rank-2 types, so can be used
--   with <a>.</a> (function composition) and in other situations where
--   <a>mapNatList</a> would cause problems.
mapNatList' :: (SomeNat -> SomeNat) -> SomeNats -> SomeNats

-- | <tt><a>KnownSymbols</a> ns</tt> is intended to represent that every
--   <a>Symbol</a> in the type-level list <tt>ns</tt> is itself a
--   <a>KnownSymbol</a> (meaning, you can use <a>symbolVal</a> to get its
--   corresponding <a>String</a>).
--   
--   You can use <a>symbolsVal</a> to get the corresponding
--   <tt>[<a>String</a>]</tt> from <tt><a>KnownSymbols</a> ns</tt>.
--   
--   For reasons discussed further in the documentation for
--   <a>KnownNats</a>, this also lets you generate a <tt><a>SymbolList</a>
--   ns</tt>, in order to iterate over the type-level list of
--   <a>Symbol</a>s and take advantage of their <a>KnownSymbol</a>
--   instances.
class KnownSymbols (ns :: [Symbol])
symbolsVal :: KnownSymbols ns => p ns -> [String]
symbolsList :: KnownSymbols ns => SymbolList ns

-- | Represents unknown type-level lists of <a>Symbol</a>s. It's a
--   <a>SymbolList</a>, but you don't know what the list contains at
--   compile-time.
data SomeSymbols :: *
SomeSymbols :: !(SymbolList ns) -> SomeSymbols

-- | Singleton-esque type for "traversing" over type-level lists of
--   <a>Symbol</a>s. Essentially contains a (value-level) list of
--   <tt><a>Proxy</a> n</tt>s, but each <tt>n</tt> has a <a>KnownSymbol</a>
--   instance for you to use. At runtime (after type erasure), is more or
--   less equivalent to a <tt>[<a>String</a>]</tt>.
--   
--   Typically generated using <a>symbolsList</a>.
data SymbolList :: [Symbol] -> *
ØSL :: SymbolList '[]
(:<$) :: !(Proxy n) -> !(SymbolList ns) -> SymbolList (n : ns)

-- | List equivalent of <a>someNatVal</a>. Convert a list of integers into
--   an unknown type-level list of naturals. Will return <a>Nothing</a> if
--   any of the given <a>Integer</a>s is negative.
someSymbolsVal :: [String] -> SomeSymbols

-- | List equivalent of <a>reifyNat</a>. Given a list of integers, takes a
--   function in an "environment" with a <tt><a>NatList</a> ns</tt>
--   corresponding to the given list, where every <tt>n</tt> in <tt>ns</tt>
--   has a <a>KnownNat</a> instance.
--   
--   Essentially a continuation-style version of <a>SomeSymbols</a>.
reifySymbols :: [String] -> (forall ns. KnownSymbols ns => SymbolList ns -> r) -> r

-- | Get evidence that the two <a>KnownSymbols</a> lists are actually the
--   "same" list of <tt>Symboles</tt>s (that they were instantiated with
--   the same strings).
--   
--   Essentialy runs <a>sameSymbol</a> over the lists:
--   
--   <pre>
--   case <a>sameSymbols</a> ns ms of
--     Just <a>Refl</a> -&gt; -- in this branch, GHC recognizes that the
--                    -- two [<a>Symbol</a>]s are the same
--     Nothing   -&gt; -- in this branch, they aren't
--   </pre>
sameSymbols :: (KnownSymbols ns, KnownSymbols ms) => SymbolList ns -> SymbolList ms -> Maybe (ns :~: ms)

-- | Utility function for traversing over all of the <tt><a>Proxy</a>
--   n</tt>s in a <a>SymbolList</a>, each with the corresponding
--   <a>KnownSymbol</a> instance available. Gives the the ability to
--   "change" the represented natural number to a new one, in a
--   <a>SomeSymbol</a>.
--   
--   Can be considered a form of a <tt>Traversal' <a>SomeSymbol</a>
--   <a>SomeSymbols</a></tt>.
traverseSymbolList :: Applicative f => (forall n. KnownSymbol n => Proxy n -> f SomeSymbol) -> SymbolList ns -> f SomeSymbols

-- | Like <a>traverseSymbolList</a>, but literally actually a
--   <tt>Traversal' <a>SomeSymbol</a> <a>SomeSymbols</a></tt>, avoiding the
--   Rank-2 types, so is usable with lens-library machinery.
traverseSymbolList' :: Applicative f => (SomeSymbol -> f SomeSymbol) -> SomeSymbols -> f SomeSymbols

-- | Utility function for traversing over all of the <tt><a>Proxy</a>
--   n</tt>s in a <a>SymbolList</a>, each with the corresponding
--   <a>KnownSymbol</a> instance available. Results are ignored.
traverseSymbolList_ :: Applicative f => (forall n a. KnownSymbol n => Proxy n -> f a) -> SymbolList ns -> f ()

-- | Utility function for "mapping" over each of the <a>Symbol</a>s in the
--   <a>SymbolList</a>.
mapSymbolList :: (forall n. KnownSymbol n => Proxy n -> SomeSymbol) -> SymbolList ns -> SomeSymbols

-- | Like <a>mapSymbolList</a>, but avoids the Rank-2 types, so can be used
--   with <a>.</a> (function composition) and in other situations where
--   <a>mapSymbolList</a> would cause problems.
mapSymbolList' :: (SomeSymbol -> SomeSymbol) -> SomeSymbols -> SomeSymbols
instance GHC.Show.Show (GHC.TypeLits.List.NatList ns)
instance GHC.Show.Show (GHC.TypeLits.List.SymbolList ns)
instance GHC.TypeLits.List.KnownNats '[]
instance (GHC.TypeLits.KnownNat n, GHC.TypeLits.List.KnownNats ns) => GHC.TypeLits.List.KnownNats (n : ns)
instance GHC.TypeLits.List.KnownSymbols '[]
instance (GHC.TypeLits.KnownSymbol n, GHC.TypeLits.List.KnownSymbols ns) => GHC.TypeLits.List.KnownSymbols (n : ns)


-- | This module provides witnesses for instances that result from the
--   various arithmetic operations on GHC TypeLits <a>Nat</a> types. In
--   general, if you have <tt><a>KnownNat</a> n</tt>, GHC can't infer
--   <tt><a>KnownNat</a> (n + 1)</tt>; and if you have <tt><a>KnownNat</a>
--   m</tt>, as well, GHC can't infer <tt><a>KnownNat</a> (n + m)</tt>.
--   
--   This can be extremely annoying when dealing with libraries and
--   applications where one regularly adds and subtracts type-level nats
--   and expects <a>KnownNat</a> instances to follow. For example, vector
--   concatenation of length-encoded vector types can be:
--   
--   <pre>
--   concat :: (<a>KnownNat</a> n, <a>KnownNat</a> m) =&gt; Vector n a -&gt; Vector m a -&gt; Vector (n + m) a
--   </pre>
--   
--   But, now <tt>n + m</tt> does not have a <a>KnownNat</a>
--   instance...which makes operations like this extremely less useful!
--   
--   At the highest level, this module can be used with <a>withNatOp</a>:
--   
--   <pre>
--   getDoubled :: forall n. <a>KnownNat</a> n =&gt; <a>Proxy</a> n -&gt; <a>Integer</a>
--   getDoubled p = <a>withNatOp</a> (<a>%*</a>) p (<a>Proxy</a> :: <a>Proxy</a> 2) $
--       natVal (<a>Proxy</a> :: <a>Proxy</a> (n * 2))
--   </pre>
--   
--   With the final argument of <a>withNatOp</a>, you can provide a result
--   computed in an environment where <tt>n * 2</tt> is indeed an instance
--   of <a>KnownNat</a>.
--   
--   For more complex usage, you can directly manipulate witnesses and then
--   use them via pattern matching:
--   
--   <pre>
--   let pn = <a>natDict</a> (<a>Proxy</a> :: <a>Proxy</a> n)
--       p1 = <a>natDict</a> (<a>Proxy</a> :: <a>Proxy</a> 1)
--       p2 = <a>natDict</a> (<a>Proxy</a> :: <a>Proxy</a> 2)
--   in  case pn <a>%*</a> p2 <a>%+</a> p1 of
--         <a>Dict</a> -&gt; <a>natVal</a> (<a>Proxy</a> :: <a>Proxy</a> (n * 2 + 1))
--   </pre>
--   
--   In the branch of the case statement, <tt>n * 2 + 1</tt> indeed has a
--   <a>KnownNat</a> instance.
--   
--   Note that the operators have appropriate fixities to mimic value-level
--   arithmetic operations.
--   
--   <b>WARNING</b>: <a>%-</a> and <a>entailSub</a> are is implemented in a
--   way such that <i>negative</i> <a>KnownNat</a>s are produced without
--   any errors. The production of witnesses and entailments will hold, but
--   be aware that any functions that rely on <a>KnownNat</a> instances to
--   be non-negative can potentially break.
module GHC.TypeLits.Witnesses

-- | A high-level the interface of this module. Give it one of the
--   witness-generating operators on <a>KnownNat</a>s in this module
--   (<a>%+</a>, <a>%-</a>, <a>%*</a>, or <a>%^</a>), two <a>Proxy</a>s
--   containing the <a>KnownNat</a>s to be modified, and receive an
--   environment where the result of the operation (applied to the
--   <a>KnownNat</a>s) has a <a>KnownNat</a> instance.
--   
--   For example, with
--   
--   <pre>
--   <a>withNatOp</a> (<a>%+</a>) (<a>Proxy</a> :: <a>Proxy</a> n) (<a>Proxy</a> :: <a>Proxy</a> 1) r
--   </pre>
--   
--   in <tt>r</tt>, <tt>n + 1</tt> has a <a>KnownNat</a> instance:
--   
--   <pre>
--   <a>withNatOp</a> (<a>%+</a>) (<a>Proxy</a> :: <a>Proxy</a> n) (<a>Proxy</a> :: <a>Proxy</a> 1) $
--       <a>natVal</a> (<a>Proxy</a> :: <a>Proxy</a> (n + 1))
--   -- =&gt; will return the <a>Integer</a> correpsonding to n + 1
--   </pre>
--   
--   Normally, if <tt>n</tt> is a <a>KnownNat</a> instance, it is not in
--   general inferrable that <tt>n + 1</tt> also has a <a>KnownNat</a>
--   instance. This combinator makes it so.
--   
--   For multiple operations on values, this can be chained:
--   
--   <pre>
--   <a>withNatOp</a> (<a>%*</a>) (<a>Proxy</a> :: <a>Proxy</a> n) (<a>Proxy</a> :: <a>Proxy</a> 2) $
--     <a>withNatOp</a> (<a>%+</a>) (<a>Proxy</a> :: <a>Proxy</a> (n*2)) (<a>Proxy</a> :: <a>Proxy</a> 1) $
--       <a>natVal</a> (<a>Proxy</a> :: <a>Proxy</a> (n * 2 + 1))
--   </pre>
--   
--   But, at this point, it's easier and simpler to just directly use the
--   operators and pattern match:
--   
--   <pre>
--   let pn = <a>natDict</a> (<a>Proxy</a> :: <a>Proxy</a> n)
--       p1 = <a>natDict</a> (<a>Proxy</a> :: <a>Proxy</a> 1)
--       p2 = <a>natDict</a> (<a>Proxy</a> :: <a>Proxy</a> 2)
--   in  case pn <a>%*</a> p2 <a>%+</a> p1 of
--         <a>Dict</a> -&gt; <a>natVal</a> (<a>Proxy</a> :: <a>Proxy</a> (n * 2 + 1))
--   </pre>
--   
--   (Note that associativity and fixity for the witness-generating
--   operators are set to match that of normal addition and multiplication,
--   etc.)
withNatOp :: (KnownNat n, KnownNat m) => (Dict (KnownNat n) -> Dict (KnownNat m) -> Dict (KnownNat q)) -> Proxy n -> Proxy m -> (KnownNat q => r) -> r

-- | Create a <a>Dict</a> witness for <tt><a>KnownNat</a> n</tt>.
natDict :: KnownNat n => Proxy n -> Dict (KnownNat n)

-- | Get the <a>Integer</a> from the <a>KnownNat</a> instance witnessed by
--   the <a>Dict</a>.
dictNatVal :: Dict (KnownNat n) -> Integer

-- | Given witnesses for <tt><a>KnownNat</a> n</tt> and <tt><a>KnownNat</a>
--   m</tt>, generates a witness for <tt><a>KnownNat</a> (n + m)</tt>.
--   
--   Follows proper association and fixity for usage with other similar
--   operators.
(%+) :: Dict (KnownNat n) -> Dict (KnownNat m) -> Dict (KnownNat (n + m))

-- | Given witnesses for <tt><a>KnownNat</a> n</tt> and <tt><a>KnownNat</a>
--   m</tt>, generates a witness for <tt><a>KnownNat</a> (n - m)</tt>.
--   
--   Note that this is implemented in a way such that <i>negative</i>
--   <a>KnownNat</a>s are produced without any errors.
--   
--   Follows proper association and fixity for usage with other similar
--   operators.
(%-) :: Dict (KnownNat n) -> Dict (KnownNat m) -> Dict (KnownNat (n - m))

-- | Given witnesses for <tt><a>KnownNat</a> n</tt> and <tt><a>KnownNat</a>
--   m</tt>, generates a witness for <tt><a>KnownNat</a> (n * m)</tt>.
--   
--   Follows proper association and fixity for usage with other similar
--   operators.
(%*) :: Dict (KnownNat n) -> Dict (KnownNat m) -> Dict (KnownNat (n * m))

-- | Given witnesses for <tt><a>KnownNat</a> n</tt> and <tt><a>KnownNat</a>
--   m</tt>, generates a witness for <tt><a>KnownNat</a> (n ^ m)</tt>.
--   
--   Follows proper association and fixity for usage with other similar
--   operators.
(%^) :: Dict (KnownNat n) -> Dict (KnownNat m) -> Dict (KnownNat (n ^ m))

-- | An entailment for addition of <a>KnownNat</a> instances.
entailAdd :: (KnownNat n, KnownNat m) :- KnownNat (n + m)

-- | An entailment for subtraction of <a>KnownNat</a> instances.
--   
--   Note that this is implemented in a way such that <i>negative</i>
--   <a>KnownNat</a>s are produced without any errors.
entailSub :: (KnownNat n, KnownNat m) :- KnownNat (n - m)

-- | An entailment for multiplication of <a>KnownNat</a> instances.
entailMul :: (KnownNat n, KnownNat m) :- KnownNat (n * m)

-- | An entailment for exponentiation of <a>KnownNat</a> instances.
entailExp :: (KnownNat n, KnownNat m) :- KnownNat (n ^ m)
