-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Existential witnesses, singletons, and classes for operations on GHC TypeLits
--   
--   Provides witnesses for <a>KnownNat</a> and <a>KnownSymbol</a>
--   instances for various operations on GHC TypeLits - in particular, the
--   arithmetic operations defined in <a>GHC.TypeLits</a>, and also for
--   type-level lists of <a>KnownNat</a> and <a>KnownSymbol</a> instances.
--   
--   This is useful for situations where you have <tt><a>KnownNat</a>
--   n</tt>, and you want to prove to GHC <tt><a>KnownNat</a> (n + 3)</tt>,
--   or <tt><a>KnownNat</a> (2*n + 4)</tt>, or when constraints on the
--   lower or upper limits of <tt>n</tt> are needed.
--   
--   It's also useful for when you want to work with type level lists of
--   <a>KnownNat</a> or <a>KnownSymbol</a> instances and singletons for
--   traversing them, and be able to apply analogies of <a>natVal</a> and
--   <a>symbolVal</a> to lists with analogies for <a>SomeNat</a> and
--   <a>SomeSymbol</a>.
--   
--   See README for more information.
@package typelits-witnesses
@version 0.2.3.0


-- | This module provides the ability to refine given <a>KnownNat</a>
--   instances using <a>GHC.TypeLits</a>'s comparison API, and also the
--   ability to prove inequalities and upper/lower limits.
--   
--   If a library function requires <tt>1 <a>&lt;=</a> n</tt> constraint,
--   but only <tt><a>KnownNat</a> n</tt> is available:
--   
--   <pre>
--   foo :: (KnownNat n, 1 <a>&lt;=</a> n) =&gt; <a>Proxy</a> n -&gt; Int
--   
--   bar :: KnownNat n =&gt; Proxy n -&gt; Int
--   bar n = case (Proxy :: Proxy 1) <a>%&lt;=?</a> n of
--             <a>LE</a>  <a>Refl</a> -&gt; foo n
--             <a>NLE</a> _    -&gt; 0
--   </pre>
--   
--   <tt>foo</tt> requires that <tt>1 &lt;= n</tt>, but <tt>bar</tt> has to
--   handle all cases of <tt>n</tt>. <tt>%&lt;=?</tt> lets you compare the
--   <a>KnownNat</a>s in two <a>Proxy</a>s and returns a <tt>:&lt;=?</tt>,
--   which has two constructors, <a>LE</a> and <a>NLE</a>.
--   
--   If you pattern match on the result, in the <a>LE</a> branch, the
--   constraint <tt>1 &lt;= n</tt> will be satisfied according to GHC, so
--   <tt>bar</tt> can safely call <tt>foo</tt>, and GHC will recognize that
--   <tt>1 &lt;= n</tt>.
--   
--   In the <a>NLE</a> branch, the constraint that <tt>1 &gt; n</tt> is
--   satisfied, so any functions that require that constraint would be
--   callable.
--   
--   For convenience, <a>isLE</a> and <a>isNLE</a> are also offered:
--   
--   <pre>
--   bar :: KnownNat n =&gt; Proxy n -&gt; Int
--   bar n = case <a>isLE</a> (Proxy :: Proxy 1) n of
--             <a>Just</a> Refl -&gt; foo n
--             <a>Nothing</a>   -&gt; 0
--   </pre>
--   
--   Similarly, if a library function requires something involving
--   <a>CmpNat</a>, you can use <a>cmpNat</a> and the <a>SCmpNat</a> type:
--   
--   <pre>
--   foo1 :: (KnownNat n, <a>CmpNat</a> 5 n ~ LT) =&gt; Proxy n -&gt; Int
--   foo2 :: (KnownNat n, CmpNat 5 n ~ GT) =&gt; Proxy n -&gt; Int
--   
--   bar :: KnownNat n =&gt; Proxy n -&gt; Int
--   bar n = case <a>cmpNat</a> (Proxy :: Proxy 5) n of
--             <a>CLT</a> Refl -&gt; foo1 n
--             <a>CEQ</a> Refl -&gt; 0
--             <a>CGT</a> Refl -&gt; foo2 n
--   </pre>
--   
--   You can use the <a>Refl</a> that <a>cmpNat</a> gives you with
--   <a>flipCmpNat</a> and <a>cmpNatLE</a> to "flip" the inequality or turn
--   it into something compatible with <a>&lt;=?</a> (useful for when you
--   have to work with libraries that mix the two methods) or
--   <a>cmpNatEq</a> and <a>eqCmpNat</a> to get to/from witnesses for
--   equality of the two <a>Nat</a>s.
module GHC.TypeLits.Compare
data (:<=?) :: Nat -> Nat -> *
[LE] :: ((m <=? n) :~: True) -> (m :<=? n)
[NLE] :: ((m <=? n) :~: False) -> (m :<=? n)
(%<=?) :: (KnownNat m, KnownNat n) => Proxy m -> Proxy n -> (m :<=? n)
isLE :: (KnownNat m, KnownNat n) => Proxy m -> Proxy n -> Maybe ((m <=? n) :~: True)
isNLE :: (KnownNat m, KnownNat n) => Proxy m -> Proxy n -> Maybe ((m <=? n) :~: False)
data SCmpNat :: Nat -> Nat -> *
[CLT] :: (CmpNat m n :~: LT) -> SCmpNat m n
[CEQ] :: (CmpNat m n :~: EQ) -> SCmpNat m n
[CGT] :: (CmpNat m n :~: GT) -> SCmpNat m n
cmpNat :: (KnownNat m, KnownNat n) => Proxy m -> Proxy n -> SCmpNat m n
flipCmpNat :: SCmpNat m n -> SCmpNat n m
cmpNatEq :: (CmpNat m n :~: EQ) -> (m :~: n)
eqCmpNat :: (m :~: n) -> (CmpNat m n :~: EQ)
cmpNatLE :: SCmpNat m n -> (m :<=? n)


-- | Provides the <a>KnownNats</a> and <a>KnownSymbols</a> typeclasses in
--   analogy to <a>KnownNat</a> and <a>KnownSymbol</a> from
--   <a>GHC.TypeLits</a>. Also provides singleton-esque structures for
--   traversing over type-level lists of <a>Nat</a>s and <a>Symbol</a>s.
--   Comes with continuation-style reifiers and existential types for
--   dependent typing usage, and as an analogy with <a>SomeNat</a> and
--   <a>SomeSymbol</a>.
--   
--   See typeclass documentations and README for more information.
module GHC.TypeLits.List

-- | <tt><a>KnownNats</a> ns</tt> is intended to represent that every
--   <a>Nat</a> in the type-level list <tt>ns</tt> is itself a
--   <a>KnownNat</a> (meaning, you can use <a>natVal</a> to get its
--   corresponding <a>Integer</a>).
--   
--   In practice, just knowing that every item has a <a>KnownNat</a>
--   instance is not enough; it's nice, but unless you're able to "iterate"
--   over every <a>Nat</a> in the list, it's of limited use. That's why
--   this class also provides a constructor for <tt><a>NatList</a> ns</tt>,
--   so that you can produce a <a>NatList</a> for every <tt><a>KnownNat</a>
--   ns</tt>, which you can iterate over to get <tt><a>Proxy</a> n</tt>s
--   for every <tt>n</tt> in <tt>ns</tt> along with the <tt><a>KnownNat</a>
--   n</tt> instances.
--   
--   It also has an analogy to <a>natVal</a>, <a>natsVal</a>, which lets
--   you get a list of the represented <a>Integer</a>s for, say,
--   <tt><a>Proxy</a> [1,2,3]</tt>.
class KnownNats (ns :: [Nat])
natsVal :: KnownNats ns => p ns -> [Integer]
natsList :: KnownNats ns => NatList ns

-- | Represents unknown type-level lists of type-level natural numbers.
--   It's a <a>NatList</a>, but you don't know what the list contains at
--   compile-time.
data SomeNats :: *
[SomeNats] :: KnownNats ns => !(NatList ns) -> SomeNats

-- | Singleton-esque type for "traversing" over type-level lists of
--   <a>Nat</a>s. Essentially contains a (value-level) list of
--   <tt><a>Proxy</a> n</tt>s, but each <tt>n</tt> has a <a>KnownNat</a>
--   instance for you to use. At runtime (after type erasure), is more or
--   less equivalent to a <tt>[<a>Integer</a>]</tt>.
--   
--   Typically generated using <a>natsList</a>.
data NatList :: [Nat] -> *
[Ã˜NL] :: NatList '[]
[:<#] :: (KnownNat n, KnownNats ns) => !(Proxy n) -> !(NatList ns) -> NatList (n : ns)

-- | List equivalent of <a>someNatVal</a>. Convert a list of integers into
--   an unknown type-level list of naturals. Will return <a>Nothing</a> if
--   any of the given <a>Integer</a>s is negative.
someNatsVal :: [Integer] -> Maybe SomeNats

-- | Like <a>someNatsVal</a>, but will also go ahead and produce
--   <a>KnownNat</a>s whose integer values are negative. It won't ever
--   error on producing them, but extra care must be taken when using the
--   produced <a>SomeNat</a>s.
someNatsValPos :: [Integer] -> SomeNats

-- | List equivalent of <a>reifyNat</a>. Given a list of integers, takes a
--   function in an "environment" with a <tt><a>NatList</a> ns</tt>
--   corresponding to the given list, where every <tt>n</tt> in <tt>ns</tt>
--   has a <a>KnownNat</a> instance.
--   
--   Essentially a continuation-style version of <a>SomeNats</a>.
--   
--   Be aware that this also produces <tt><a>KnownNat</a> n</tt>s where
--   <tt>n</tt> is negative, without complaining. To be consistent, within
--   the library, this <i>should</i> be called <tt>reifyNatsPos</tt>;
--   however, the naming choice is for consistency with <a>reifyNat</a>
--   from the <i>reflections</i> package. Use <a>reifyNats'</a> for a
--   "safe" version.
reifyNats :: [Integer] -> (forall ns. KnownNats ns => NatList ns -> r) -> r

-- | <a>Safe</a> version of <a>reifyNats</a>, which will only run the
--   continuation if every <a>Integer</a> in the list is non-negative. If
--   not, then returns the given "default" value instead.
reifyNats' :: [Integer] -> r -> (forall ns. KnownNats ns => NatList ns -> r) -> r

-- | Get evidence that the two <a>KnownNats</a> lists are actually the
--   "same" list of <a>Nat</a>s (that they were instantiated with the same
--   numbers).
--   
--   Essentialy runs <a>sameNat</a> over the lists:
--   
--   <pre>
--   case <a>sameNats</a> ns ms of
--     Just <a>Refl</a> -&gt; -- in this branch, GHC recognizes that the two [<a>Nat</a>]s
--                    -- are the same.
--     Nothing   -&gt; -- in this branch, they aren't
--   </pre>
sameNats :: NatList ns -> NatList ms -> Maybe (ns :~: ms)

-- | The "eliminator" for <a>NatList</a>. You can think of this as a
--   dependently typed analogy for a fold.
--   
--   <i>Since 0.2.1.0</i>
elimNatList :: forall p ns. p '[] -> (forall m ms. (KnownNat m, KnownNats ms) => Proxy m -> p ms -> p (m : ms)) -> NatList ns -> p ns

-- | Utility function for traversing over all of the <tt><a>Proxy</a>
--   n</tt>s in a <a>NatList</a>, each with the corresponding
--   <a>KnownNat</a> instance available. Gives the the ability to "change"
--   the represented natural number to a new one, in a <a>SomeNat</a>.
--   
--   Can be considered a form of a <tt>Traversal' <a>SomeNats</a>
--   <a>SomeNat</a></tt>.
traverseNatList :: forall f ns. Applicative f => (forall n. KnownNat n => Proxy n -> f SomeNat) -> NatList ns -> f SomeNats

-- | Like <a>traverseNatList</a>, but literally actually a <tt>Traversal'
--   <a>SomeNats</a> <a>SomeNat</a></tt>, avoiding the Rank-2 types, so is
--   usable with lens-library machinery.
traverseNatList' :: forall f. Applicative f => (SomeNat -> f SomeNat) -> SomeNats -> f SomeNats

-- | Utility function for traversing over all of the <tt><a>Proxy</a>
--   n</tt>s in a <a>NatList</a>, each with the corresponding
--   <a>KnownNat</a> instance available. Results are ignored.
traverseNatList_ :: forall f a ns. Applicative f => (forall n. KnownNat n => Proxy n -> f a) -> NatList ns -> f ()

-- | Utility function for "mapping" over each of the <a>Nat</a>s in the
--   <a>NatList</a>.
mapNatList :: (forall n. KnownNat n => Proxy n -> SomeNat) -> NatList ns -> SomeNats

-- | Like <a>mapNatList</a>, but avoids the Rank-2 types, so can be used
--   with <a>.</a> (function composition) and in other situations where
--   <a>mapNatList</a> would cause problems.
mapNatList' :: (SomeNat -> SomeNat) -> SomeNats -> SomeNats

-- | <tt><a>KnownSymbols</a> ss</tt> is intended to represent that every
--   <a>Symbol</a> in the type-level list <tt>ss</tt> is itself a
--   <a>KnownSymbol</a> (meaning, you can use <a>symbolVal</a> to get its
--   corresponding <a>String</a>).
--   
--   You can use <a>symbolsVal</a> to get the corresponding
--   <tt>[<a>String</a>]</tt> from <tt><a>KnownSymbols</a> ss</tt>.
--   
--   For reasons discussed further in the documentation for
--   <a>KnownNats</a>, this also lets you generate a <tt><a>SymbolList</a>
--   ss</tt>, in order to iterate over the type-level list of
--   <a>Symbol</a>s and take advantage of their <a>KnownSymbol</a>
--   instances.
class KnownSymbols (ss :: [Symbol])
symbolsVal :: KnownSymbols ss => p ss -> [String]
symbolsList :: KnownSymbols ss => SymbolList ss

-- | Represents unknown type-level lists of <a>Symbol</a>s. It's a
--   <a>SymbolList</a>, but you don't know what the list contains at
--   compile-time.
data SomeSymbols :: *
[SomeSymbols] :: KnownSymbols ss => !(SymbolList ss) -> SomeSymbols

-- | Singleton-esque type for "traversing" over type-level lists of
--   <a>Symbol</a>s. Essentially contains a (value-level) list of
--   <tt><a>Proxy</a> n</tt>s, but each <tt>n</tt> has a <a>KnownSymbol</a>
--   instance for you to use. At runtime (after type erasure), is more or
--   less equivalent to a <tt>[<a>String</a>]</tt>.
--   
--   Typically generated using <a>symbolsList</a>.
data SymbolList :: [Symbol] -> *
[Ã˜SL] :: SymbolList '[]
[:<$] :: (KnownSymbol s, KnownSymbols ss) => !(Proxy s) -> !(SymbolList ss) -> SymbolList (s : ss)

-- | List equivalent of <a>someNatVal</a>. Convert a list of integers into
--   an unknown type-level list of naturals. Will return <a>Nothing</a> if
--   any of the given <a>Integer</a>s is negative.
someSymbolsVal :: [String] -> SomeSymbols

-- | List equivalent of <a>reifyNat</a>. Given a list of integers, takes a
--   function in an "environment" with a <tt><a>SymbolList</a> ss</tt>
--   corresponding to the given list, where every <tt>s</tt> in <tt>ss</tt>
--   has a <a>KnownSymbol</a> instance.
--   
--   Essentially a continuation-style version of <a>SomeSymbols</a>.
reifySymbols :: [String] -> (forall ss. KnownSymbols ss => SymbolList ss -> r) -> r

-- | Get evidence that the two <a>KnownSymbols</a> lists are actually the
--   "same" list of <tt>Symboles</tt>s (that they were instantiated with
--   the same strings).
--   
--   Essentialy runs <a>sameSymbol</a> over the lists:
--   
--   <pre>
--   case <a>sameSymbols</a> ns ms of
--     Just <a>Refl</a> -&gt; -- in this branch, GHC recognizes that the
--                    -- two [<a>Symbol</a>]s are the same
--     Nothing   -&gt; -- in this branch, they aren't
--   </pre>
sameSymbols :: SymbolList ns -> SymbolList ms -> Maybe (ns :~: ms)

-- | The "eliminator" for <a>SymbolList</a>. You can think of this as a
--   dependently typed analogy for a fold.
--   
--   <i>Since 0.2.1.0</i>
elimSymbolList :: forall p ss. p '[] -> (forall t ts. (KnownSymbol t, KnownSymbols ts) => Proxy t -> p ts -> p (t : ts)) -> SymbolList ss -> p ss

-- | Utility function for traversing over all of the <tt><a>Proxy</a>
--   s</tt>s in a <a>SymbolList</a>, each with the corresponding
--   <a>KnownSymbol</a> instance available. Gives the the ability to
--   "change" the represented natural number to a new one, in a
--   <a>SomeSymbol</a>.
--   
--   Can be considered a form of a <tt>Traversal' <a>SomeSymbols</a>
--   <a>SomeSymbol</a></tt>.
traverseSymbolList :: forall f ss. Applicative f => (forall s. KnownSymbol s => Proxy s -> f SomeSymbol) -> SymbolList ss -> f SomeSymbols

-- | Like <a>traverseSymbolList</a>, but literally actually a
--   <tt>Traversal' <a>SomeSymbols</a> <a>SomeSymbol</a></tt>, avoiding the
--   Rank-2 types, so is usable with lens-library machinery.
traverseSymbolList' :: forall f. Applicative f => (SomeSymbol -> f SomeSymbol) -> SomeSymbols -> f SomeSymbols

-- | Utility function for traversing over all of the <tt><a>Proxy</a>
--   s</tt>s in a <a>SymbolList</a>, each with the corresponding
--   <a>KnownSymbol</a> instance available. Results are ignored.
traverseSymbolList_ :: forall f ss. Applicative f => (forall s a. KnownSymbol s => Proxy s -> f a) -> SymbolList ss -> f ()

-- | Utility function for "mapping" over each of the <a>Symbol</a>s in the
--   <a>SymbolList</a>.
mapSymbolList :: (forall s. KnownSymbol s => Proxy s -> SomeSymbol) -> SymbolList ss -> SomeSymbols

-- | Like <a>mapSymbolList</a>, but avoids the Rank-2 types, so can be used
--   with <a>.</a> (function composition) and in other situations where
--   <a>mapSymbolList</a> would cause problems.
mapSymbolList' :: (SomeSymbol -> SomeSymbol) -> SomeSymbols -> SomeSymbols
instance GHC.Show.Show (GHC.TypeLits.List.NatList ns)
instance GHC.Show.Show (GHC.TypeLits.List.SymbolList ns)
instance GHC.TypeLits.List.KnownNats '[]
instance (GHC.TypeLits.KnownNat n, GHC.TypeLits.List.KnownNats ns) => GHC.TypeLits.List.KnownNats (n : ns)
instance GHC.TypeLits.List.KnownSymbols '[]
instance (GHC.TypeLits.KnownSymbol s, GHC.TypeLits.List.KnownSymbols ss) => GHC.TypeLits.List.KnownSymbols (s : ss)


-- | This module provides witnesses for instances that result from the
--   various arithmetic operations on GHC TypeLits <a>Nat</a> types. In
--   general, if you have <tt><a>KnownNat</a> n</tt>, GHC can't infer
--   <tt><a>KnownNat</a> (n + 1)</tt>; and if you have <tt><a>KnownNat</a>
--   m</tt>, as well, GHC can't infer <tt><a>KnownNat</a> (n + m)</tt>.
--   
--   This can be extremely annoying when dealing with libraries and
--   applications where one regularly adds and subtracts type-level nats
--   and expects <a>KnownNat</a> instances to follow. For example, vector
--   concatenation of length-encoded vector types can be:
--   
--   <pre>
--   concat :: (<a>KnownNat</a> n, <a>KnownNat</a> m) =&gt; Vector n a -&gt; Vector m a -&gt; Vector (n + m) a
--   </pre>
--   
--   But, now <tt>n + m</tt> does not have a <a>KnownNat</a>
--   instance...which makes operations like this extremely less useful!
--   
--   At the highest level, this module can be used with <a>withNatOp</a>:
--   
--   <pre>
--   getDoubled :: forall n. <a>KnownNat</a> n =&gt; <a>Proxy</a> n -&gt; <a>Integer</a>
--   getDoubled p = <a>withNatOp</a> (<a>%*</a>) p (<a>Proxy</a> :: <a>Proxy</a> 2) $
--       natVal (<a>Proxy</a> :: <a>Proxy</a> (n * 2))
--   </pre>
--   
--   With the final argument of <a>withNatOp</a>, you can provide a result
--   computed in an environment where <tt>n * 2</tt> is indeed an instance
--   of <a>KnownNat</a>.
--   
--   For more complex usage, you can directly manipulate witnesses and then
--   use them via pattern matching:
--   
--   <pre>
--   let pn = <a>natDict</a> (<a>Proxy</a> :: <a>Proxy</a> n)
--       p1 = <a>natDict</a> (<a>Proxy</a> :: <a>Proxy</a> 1)
--       p2 = <a>natDict</a> (<a>Proxy</a> :: <a>Proxy</a> 2)
--   in  case pn <a>%*</a> p2 <a>%+</a> p1 of
--         <a>Dict</a> -&gt; <a>natVal</a> (<a>Proxy</a> :: <a>Proxy</a> (n * 2 + 1))
--   </pre>
--   
--   In the branch of the case statement, <tt>n * 2 + 1</tt> indeed has a
--   <a>KnownNat</a> instance.
--   
--   Note that the operators have appropriate fixities to mimic value-level
--   arithmetic operations.
--   
--   <b>WARNING</b>: <a>%-</a> and <a>entailSub</a> are is implemented in a
--   way such that <i>negative</i> <a>KnownNat</a>s are produced without
--   any errors. The production of witnesses and entailments will hold, but
--   be aware that any functions that rely on <a>KnownNat</a> instances to
--   be non-negative can potentially break.
module GHC.TypeLits.Witnesses

-- | A high-level the interface of this module. Give it one of the
--   witness-generating operators on <a>KnownNat</a>s in this module
--   (<a>%+</a>, <a>%-</a>, <a>%*</a>, or <a>%^</a>), two <a>Proxy</a>s
--   containing the <a>KnownNat</a>s to be modified, and receive an
--   environment where the result of the operation (applied to the
--   <a>KnownNat</a>s) has a <a>KnownNat</a> instance.
--   
--   For example, with
--   
--   <pre>
--   <a>withNatOp</a> (<a>%+</a>) (<a>Proxy</a> :: <a>Proxy</a> n) (<a>Proxy</a> :: <a>Proxy</a> 1) r
--   </pre>
--   
--   in <tt>r</tt>, <tt>n + 1</tt> has a <a>KnownNat</a> instance:
--   
--   <pre>
--   <a>withNatOp</a> (<a>%+</a>) (<a>Proxy</a> :: <a>Proxy</a> n) (<a>Proxy</a> :: <a>Proxy</a> 1) $
--       <a>natVal</a> (<a>Proxy</a> :: <a>Proxy</a> (n + 1))
--   -- =&gt; will return the <a>Integer</a> correpsonding to n + 1
--   </pre>
--   
--   Normally, if <tt>n</tt> is a <a>KnownNat</a> instance, it is not in
--   general inferrable that <tt>n + 1</tt> also has a <a>KnownNat</a>
--   instance. This combinator makes it so.
--   
--   For multiple operations on values, this can be chained:
--   
--   <pre>
--   <a>withNatOp</a> (<a>%*</a>) (<a>Proxy</a> :: <a>Proxy</a> n) (<a>Proxy</a> :: <a>Proxy</a> 2) $
--     <a>withNatOp</a> (<a>%+</a>) (<a>Proxy</a> :: <a>Proxy</a> (n*2)) (<a>Proxy</a> :: <a>Proxy</a> 1) $
--       <a>natVal</a> (<a>Proxy</a> :: <a>Proxy</a> (n * 2 + 1))
--   </pre>
--   
--   But, at this point, it's easier and simpler to just directly use the
--   operators and pattern match:
--   
--   <pre>
--   let pn = <a>natDict</a> (<a>Proxy</a> :: <a>Proxy</a> n)
--       p1 = <a>natDict</a> (<a>Proxy</a> :: <a>Proxy</a> 1)
--       p2 = <a>natDict</a> (<a>Proxy</a> :: <a>Proxy</a> 2)
--   in  case pn <a>%*</a> p2 <a>%+</a> p1 of
--         <a>Dict</a> -&gt; <a>natVal</a> (<a>Proxy</a> :: <a>Proxy</a> (n * 2 + 1))
--   </pre>
--   
--   (Note that associativity and fixity for the witness-generating
--   operators are set to match that of normal addition and multiplication,
--   etc.)
withNatOp :: (KnownNat n, KnownNat m) => (Dict (KnownNat n) -> Dict (KnownNat m) -> Dict (KnownNat q)) -> Proxy n -> Proxy m -> (KnownNat q => r) -> r

-- | Create a <a>Dict</a> witness for <tt><a>KnownNat</a> n</tt>.
natDict :: KnownNat n => Proxy n -> Dict (KnownNat n)

-- | Get the <a>Integer</a> from the <a>KnownNat</a> instance witnessed by
--   the <a>Dict</a>.
dictNatVal :: forall n. Dict (KnownNat n) -> Integer

-- | Given witnesses for <tt><a>KnownNat</a> n</tt> and <tt><a>KnownNat</a>
--   m</tt>, generates a witness for <tt><a>KnownNat</a> (n + m)</tt>.
--   
--   Follows proper association and fixity for usage with other similar
--   operators.
(%+) :: forall n m. Dict (KnownNat n) -> Dict (KnownNat m) -> Dict (KnownNat (n + m))
infixl 6 %+

-- | Given witnesses for <tt><a>KnownNat</a> n</tt> and <tt><a>KnownNat</a>
--   m</tt>, generates a witness for <tt><a>KnownNat</a> (n - m)</tt>.
--   
--   Note that this is implemented in a way such that <i>negative</i>
--   <a>KnownNat</a>s are produced without any errors.
--   
--   Follows proper association and fixity for usage with other similar
--   operators.
(%-) :: forall n m. Dict (KnownNat n) -> Dict (KnownNat m) -> Dict (KnownNat (n - m))
infixl 6 %-

-- | Given witnesses for <tt><a>KnownNat</a> n</tt> and <tt><a>KnownNat</a>
--   m</tt>, generates a witness for <tt><a>KnownNat</a> (n * m)</tt>.
--   
--   Follows proper association and fixity for usage with other similar
--   operators.
(%*) :: forall n m. Dict (KnownNat n) -> Dict (KnownNat m) -> Dict (KnownNat (n * m))
infixl 7 %*

-- | Given witnesses for <tt><a>KnownNat</a> n</tt> and <tt><a>KnownNat</a>
--   m</tt>, generates a witness for <tt><a>KnownNat</a> (n ^ m)</tt>.
--   
--   Follows proper association and fixity for usage with other similar
--   operators.
(%^) :: forall n m. Dict (KnownNat n) -> Dict (KnownNat m) -> Dict (KnownNat (n ^ m))
infixr 8 %^

-- | An entailment for addition of <a>KnownNat</a> instances.
entailAdd :: forall n m. (KnownNat n, KnownNat m) :- KnownNat (n + m)

-- | An entailment for subtraction of <a>KnownNat</a> instances.
--   
--   Note that this is implemented in a way such that <i>negative</i>
--   <a>KnownNat</a>s are produced without any errors.
entailSub :: forall n m. (KnownNat n, KnownNat m) :- KnownNat (n - m)

-- | An entailment for multiplication of <a>KnownNat</a> instances.
entailMul :: forall n m. (KnownNat n, KnownNat m) :- KnownNat (n * m)

-- | An entailment for exponentiation of <a>KnownNat</a> instances.
entailExp :: forall n m. (KnownNat n, KnownNat m) :- KnownNat (n ^ m)
