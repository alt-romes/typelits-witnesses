-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Existential witnesses, singletons, and classes for operations on GHC TypeLits
--   
--   This library contains:
--   
--   <ul>
--   <li>A small specialized subset of the *singletons* library as it
--   pertains to <a>Nat</a> and <a>Symbol</a>, for when you need some
--   simple functionality without wanting to invoke the entire *singletons*
--   library.</li>
--   <li>Operations for manipulating these singletons and <a>KnownNat</a>
--   and <a>KnownSymbol</a> instances, such as addition and multiplication
--   of singletons/<a>KnownNat</a> instances.</li>
--   <li>Operations for the comparison of <a>Nat</a>s in a way that works
--   well with</li>
--   <li>GHC.TypeLits*'s different comparison systems. This is helpful for
--   bridging together libraries that use different systems; this
--   functionality is not yet provided by *singletons*.</li>
--   </ul>
@package typelits-witnesses
@version 0.4.0.0


-- | This module provides the ability to refine given <a>KnownNat</a>
--   instances using <a>GHC.TypeLits</a>'s comparison API, and also the
--   ability to prove inequalities and upper/lower limits.
--   
--   If a library function requires <tt>1 <a>&lt;=</a> n</tt> constraint,
--   but only <tt><a>KnownNat</a> n</tt> is available:
--   
--   <pre>
--   foo :: (KnownNat n, 1 <a>&lt;=</a> n) =&gt; <a>Proxy</a> n -&gt; Int
--   
--   bar :: KnownNat n =&gt; Proxy n -&gt; Int
--   bar n = case (Proxy :: Proxy 1) <a>%&lt;=?</a> n of
--             <a>LE</a>  <a>Refl</a> -&gt; foo n
--             <a>NLE</a> _    -&gt; 0
--   </pre>
--   
--   <tt>foo</tt> requires that <tt>1 &lt;= n</tt>, but <tt>bar</tt> has to
--   handle all cases of <tt>n</tt>. <tt>%&lt;=?</tt> lets you compare the
--   <a>KnownNat</a>s in two <a>Proxy</a>s and returns a <tt>:&lt;=?</tt>,
--   which has two constructors, <a>LE</a> and <a>NLE</a>.
--   
--   If you pattern match on the result, in the <a>LE</a> branch, the
--   constraint <tt>1 &lt;= n</tt> will be satisfied according to GHC, so
--   <tt>bar</tt> can safely call <tt>foo</tt>, and GHC will recognize that
--   <tt>1 &lt;= n</tt>.
--   
--   In the <a>NLE</a> branch, the constraint that <tt>1 &gt; n</tt> is
--   satisfied, so any functions that require that constraint would be
--   callable.
--   
--   For convenience, <a>isLE</a> and <a>isNLE</a> are also offered:
--   
--   <pre>
--   bar :: KnownNat n =&gt; Proxy n -&gt; Int
--   bar n = case <a>isLE</a> (Proxy :: Proxy 1) n of
--             <a>Just</a> Refl -&gt; foo n
--             <a>Nothing</a>   -&gt; 0
--   </pre>
--   
--   Similarly, if a library function requires something involving
--   <a>CmpNat</a>, you can use <a>cmpNat</a> and the <a>SCmpNat</a> type:
--   
--   <pre>
--   foo1 :: (KnownNat n, <a>CmpNat</a> 5 n ~ LT) =&gt; Proxy n -&gt; Int
--   foo2 :: (KnownNat n, CmpNat 5 n ~ GT) =&gt; Proxy n -&gt; Int
--   
--   bar :: KnownNat n =&gt; Proxy n -&gt; Int
--   bar n = case <a>cmpNat</a> (Proxy :: Proxy 5) n of
--             <a>CLT</a> Refl -&gt; foo1 n
--             <a>CEQ</a> Refl -&gt; 0
--             <a>CGT</a> Refl -&gt; foo2 n
--   </pre>
--   
--   You can use the <a>Refl</a> that <a>cmpNat</a> gives you with
--   <a>flipCmpNat</a> and <a>cmpNatLE</a> to "flip" the inequality or turn
--   it into something compatible with <a>&lt;=?</a> (useful for when you
--   have to work with libraries that mix the two methods) or
--   <a>cmpNatEq</a> and <a>eqCmpNat</a> to get to/from witnesses for
--   equality of the two <a>Nat</a>s.
--   
--   This module is useful for helping bridge between libraries that use
--   different <a>Nat</a>-based comparison systems in their type
--   constraints.
module GHC.TypeLits.Compare

-- | Two possible ordered relationships between two natural numbers.
data (:<=?) :: Nat -> Nat -> Type
[LE] :: ((m <=? n) :~:  'True) -> m :<=? n
[NLE] :: ((m <=? n) :~:  'False) -> ((n <=? m) :~:  'True) -> m :<=? n

-- | Compare <tt>m</tt> and <tt>n</tt>, classifying their relationship into
--   some constructor of <a>:&lt;=?</a>.
(%<=?) :: (KnownNat m, KnownNat n) => p m -> q n -> m :<=? n

-- | Simplified version of <a>%&lt;=?</a>: check if <tt>m</tt> is less than
--   or equal to to <tt>n</tt>. If it is, match on <tt><a>Just</a>
--   <a>Refl</a></tt> to get GHC to believe it, within the body of the
--   pattern match.
isLE :: (KnownNat m, KnownNat n) => p m -> q n -> Maybe ((m <=? n) :~:  'True)

-- | Simplified version of <a>%&lt;=?</a>: check if <tt>m</tt> is not less
--   than or equal to to <tt>n</tt>. If it is, match on <tt><a>Just</a>
--   <a>Refl</a></tt> to get GHC to believe it, within the body of the
--   pattern match.
isNLE :: (KnownNat m, KnownNat n) => p m -> q n -> Maybe ((m <=? n) :~:  'False)

-- | Three possible ordered relationships between two natural numbers.
data SCmpNat :: Nat -> Nat -> Type
[CLT] :: (CmpNat m n :~:  'LT) -> SCmpNat m n
[CEQ] :: (CmpNat m n :~:  'EQ) -> (m :~: n) -> SCmpNat m n
[CGT] :: (CmpNat m n :~:  'GT) -> SCmpNat m n

-- | Compare <tt>m</tt> and <tt>n</tt>, classifying their relationship into
--   some constructor of <a>SCmpNat</a>.
cmpNat :: (KnownNat m, KnownNat n) => p m -> q n -> SCmpNat m n

-- | Flip an inequality.
flipCmpNat :: SCmpNat m n -> SCmpNat n m

-- | <tt><a>CmpNat</a> m n</tt> being <a>EQ</a> implies that <tt>m</tt> is
--   equal to <tt>n</tt>.
cmpNatEq :: (CmpNat m n :~:  'EQ) -> m :~: n

-- | A witness of equality implies that <tt><a>CmpNat</a> m n</tt> is
--   <a>Eq</a>.
eqCmpNat :: (m :~: n) -> CmpNat m n :~:  'EQ

-- | Inject a witness of equality into an <a>SCmpNat</a> at <a>CEQ</a>.
reflCmpNat :: (m :~: n) -> SCmpNat m n

-- | Convert to <a>:&lt;=?</a>
cmpNatLE :: SCmpNat m n -> m :<=? n

-- | Convert to <a>GOrdering</a>
cmpNatGOrdering :: SCmpNat n m -> GOrdering n m


-- | This module essentially provides a lightweight subset of the
--   <i>singletons</i> library specifically for <a>Nat</a> and
--   <a>Symbol</a>, from <a>GHC.TypeLits</a>.
--   
--   Its main functionality is for first-class manipulation of
--   <a>KnownNat</a> and <a>KnownSymbol</a> constraints. For example, in
--   general, if you have <tt><a>KnownNat</a> n</tt>, GHC can't infer
--   <tt><a>KnownNat</a> (n + 1)</tt>. And, if you have both
--   <tt><a>KnownNat</a> n</tt> and <tt><a>KnownNat</a> m</tt>, GHC can't
--   infer <tt>'KnownNat (n + m)</tt>.
--   
--   This can be annoying when dealing with libraries and applications
--   where one regularly adds and subtracts type-level nats and expects
--   <a>KnownNat</a> instances to follow. For example, vector concatenation
--   of length-encoded vector types can be:
--   
--   <pre>
--   concat :: (<a>KnownNat</a> n, <a>KnownNat</a> m) =&gt; Vector n a -&gt; Vector m a -&gt; Vector (n + m) a
--   </pre>
--   
--   But, now <tt>n + m</tt> does not have a <a>KnownNat</a>
--   instance...which makes operations like this much less useful.
--   
--   Usually, the easiest way to get around this is to use a typechecker
--   plugin, like
--   <a>https://hackage.haskell.org/package/ghc-typelits-knownnat</a>.
--   However, we can do this without the help of a typechecker plugin using
--   first-class values, at the cost of some increased verbosity.
--   
--   We introduce <tt><a>SNat</a> n</tt>, which is a term-level witness of
--   knownnat-ness that can be manipulated as a first-class value.
--   
--   If we have <tt><a>KnownNat</a> n</tt>, we can construct an
--   <tt><a>SNat</a> n</tt>:
--   
--   <pre>
--   <a>SNat</a> :: KnownNat n -&gt; SNat n
--   </pre>
--   
--   Furthermore, if we have an <tt><a>SNat</a> n</tt>, we can <i>pattern
--   match</i> on the <a>SNat</a> constructor to get a <tt><a>KnownNat</a>
--   n</tt> constraint:
--   
--   <pre>
--   myFunc :: SNat n -&gt; Bool
--   myFunc SNat = ...  -- in this body, we have `KnownNat n`
--   </pre>
--   
--   So if we have <tt><a>KnownNat</a> n</tt> and <tt><a>KnownNat</a>
--   m</tt>, we can get <tt><a>KnownNat</a> (n + m)</tt> by using
--   <a>%+</a>, which adds together <a>SNat</a>s:
--   
--   <pre>
--   case (SNat :: SNat n) %+ (SNat :: SNat m) of
--     SNat -&gt; -- in this branch, we have `KnownNat (n + m)`
--   </pre>
--   
--   Note that this module converts between <a>SNat</a> and <a>Natural</a>,
--   and not <a>SNat</a> and <a>Integer</a>, in <a>GHC.TypeNats</a>-style.
--   
--   Of course, all of this functionality is provided by the
--   <i>singletons</i> library, in <a>Data.Singletons.TypeLits</a>. This
--   module can be useful if you want a lightweight alternative without the
--   full might of <i>singletons</i>. The main benefit of the
--   <i>singletons</i> library is providing a unified interface for
--   singletons of <i>all</i> different kinds/types, and not just
--   <a>Natural</a> and <a>String</a>.
module GHC.TypeLits.Witnesses

-- | An <tt><a>SNat</a> n</tt> is a witness for <tt><a>KnownNat</a> n</tt>.
--   
--   This means that if you pattern match on the <a>SNat</a> constructor,
--   in that branch you will have a <tt><a>KnownNat</a> n</tt> constraint.
--   
--   <pre>
--   myFunc :: SNat n -&gt; Bool
--   myFunc SNat = ...  -- in this body, we have `KnownNat n`
--   </pre>
--   
--   This is essentially a singleton for <a>Nat</a>, and stands in for the
--   <i>singletons</i> <a>SNat</a> and <a>Sing</a> types.
data SNat n
SNat :: SNat n

-- | This type represents unknown type-level natural numbers.
data SomeNat

-- | A useful pattern synonym for matching on a <a>SomeNat</a> as if it
--   contained an <tt><a>SNat</a> n</tt>, and not a <tt><a>Proxy</a> n</tt>
--   as it exists in <a>GHC.TypeLits</a>.
--   
--   A layer of compatibility letting us use the original <a>SomeNat</a>
--   type in a way that works well with <a>SNat</a>.
--   
--   This stands in for the <i>singletons</i> <a>SomeSing</a> constructor.
pattern SomeNat_ :: SNat n -> SomeNat

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^100 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><tt>throw</tt>
--   (<tt>Underflow</tt> :: <tt>ArithException</tt>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | A useful pattern synonym for matching on a <a>Natural</a> as if it
--   "were" a <a>SNat</a>:
--   
--   <pre>
--   myFunc :: Natural -&gt; Bool
--   myFunc (FromSNat x) = ...  -- x is `SNat n`, with <tt>n</tt> coming from the input
--   </pre>
--   
--   It can be used as a function, as well, to convert an <tt><a>SNat</a>
--   n</tt> back into the <a>Natural</a> that it represents.
--   
--   This stands in for the <i>singletons</i> <a>FromSing</a> pattern
--   synonym.
pattern FromSNat :: SNat n -> Natural

-- | Convert ("reflect") an <a>SNat</a> back into the <a>Natural</a> it
--   represents.
--   
--   This stands in the <i>singletons</i> <a>fromSing</a> function.
fromSNat :: SNat n -> Natural

-- | Given an <tt><a>SNat</a> n</tt> and a value that would require a
--   <tt><a>KnownNat</a> n</tt> instance, create that value.
--   
--   This stands in for the function of the same name from
--   <a>Data.Singletons.TypeLits</a>.
withKnownNat :: SNat n -> (KnownNat n => r) -> r

-- | Promote ("reify") a <a>Natural</a> to an <tt><a>SNat</a> n</tt>, by
--   providing a continuation that would handle it in a way that is
--   polymorphic over all possible <tt>n</tt>.
--   
--   This stands in the <i>singletons</i> <a>withSomeSing</a> function.
withSomeNat :: Natural -> (forall n. SNat n -> r) -> r

-- | Promote ("reify") a <a>Natural</a> to an <tt><a>SNat</a> n</tt>
--   existentially hidden inside a <a>SomeNat</a>. To use it, pattern match
--   using <a>SomeNat_</a>.
--   
--   This stands in the <i>singletons</i> <a>toSomeSing</a> function.
toSomeNat :: Natural -> SomeNat

-- | Addition of <a>SNat</a>s.
--   
--   This also will provide the correct <a>KnownNat</a> instance for
--   <tt><a>SNat</a> (n + m)</tt>, so can be used as a way to "add"
--   <a>KnownNat</a> instances.
--   
--   This stands in for the function with the same name from
--   <a>Data.Singletons.Prelude.Num</a>.
(%+) :: SNat n -> SNat m -> SNat (n + m)

-- | Subtraction of <a>SNat</a>s. Note that this is unsafe, as will trigger
--   a run-time underflow if <tt>m</tt> is bigger than <tt>n</tt> even
--   though it will always succeed at compiletime.
--   
--   This also will provide the correct <a>KnownNat</a> instance for
--   <tt><a>SNat</a> (n - m)</tt>, so can be used as a way to "subtract"
--   <a>KnownNat</a> instances.
--   
--   This stands in for the function with the same name from
--   <a>Data.Singletons.Prelude.Num</a>.
(%-) :: SNat n -> SNat m -> SNat (n - m)

-- | A safe version of <a>%-</a>: it will return <a>Left</a> if <tt>n</tt>
--   is less than <tt>m</tt> (with a witness that it is), or else return
--   the subtracted <a>SNat</a> in <a>Right</a> in a way that is guarunteed
--   to not have runtime underflow.
minusSNat :: SNat n -> SNat m -> Either (CmpNat n m :~:  'LT) (SNat (n - m))

-- | A version of <a>minusSNat</a> that just returns a <a>Maybe</a>.
minusSNat_ :: SNat n -> SNat m -> Maybe (SNat (n - m))

-- | Addition of <a>SNat</a>s.
--   
--   This also will provide the correct <a>KnownNat</a> instance for
--   <tt><a>SNat</a> (n * m)</tt>, so can be used as a way to "multiply"
--   <a>KnownNat</a> instances.
--   
--   This stands in for the function with the same name from
--   <a>Data.Singletons.Prelude.Num</a>.
(%*) :: SNat n -> SNat m -> SNat (n - m)

-- | Exponentiation of <a>SNat</a>s.
--   
--   This also will provide the correct <a>KnownNat</a> instance for
--   <tt><a>SNat</a> (n ^ m)</tt>, so can be used as a way to
--   "exponentiate" <a>KnownNat</a> instances.
--   
--   This stands in for the function with the same name from
--   <a>Data.Singletons.TypeLits</a>.
(%^) :: SNat n -> SNat m -> SNat (n ^ m)

-- | Compare <tt>n</tt> and <tt>m</tt>, categorizing them into one of the
--   constructors of <a>:&lt;=?</a>.
(%<=?) :: SNat n -> SNat m -> n :<=? m

-- | Compare <tt>n</tt> and <tt>m</tt>, categorizing them into one of the
--   constructors of <a>SCmpNat</a>.
sCmpNat :: SNat n -> SNat m -> SCmpNat n m

-- | Lift a unary operation to act on an <tt><a>SNat</a> n</tt> that
--   returns an <tt><a>SNat</a> m</tt>. The function given must properly
--   describe the relationship between <tt>n</tt> and <tt>m</tt>.
--   
--   For example:
--   
--   <pre>
--   double :: SNat n -&gt; SNat (n * 2)
--   double = unsafeLiftNatOp1 (*2)
--   </pre>
--   
--   The correctness of the relationship is not checked, so be aware that
--   this can cause programs to break.
unsafeLiftNatOp1 :: (Natural -> Natural) -> SNat n -> SNat m

-- | Lift a binary operation to act on an <tt><a>SNat</a> n</tt> and
--   <tt><a>SNat</a> m</tt> that returns an <tt><a>SNat</a> o</tt>. The
--   function given must properly describe the relationship between
--   <tt>n</tt>, <tt>m</tt>, and <tt>o</tt>.
--   
--   For example:
--   
--   <pre>
--   multiply :: SNat n -&gt; SNat m -&gt; SNat (n * m)
--   multiply = unsafeLiftNatOp2 (*)
--   </pre>
--   
--   The correctness of the relationship is not checked, so be aware that
--   this can cause programs to break.
unsafeLiftNatOp2 :: (Natural -> Natural -> Natural) -> SNat n -> SNat m -> SNat o

-- | An <tt><a>SSymbol</a> n</tt> is a witness for <tt><a>KnownSymbol</a>
--   n</tt>.
--   
--   This means that if you pattern match on the <a>SSymbol</a>
--   constructor, in that branch you will have a <tt><a>KnownSymbol</a>
--   n</tt> constraint.
--   
--   <pre>
--   myFunc :: SSymbol n -&gt; Bool
--   myFunc SSymbol = ...  -- in this body, we have `KnownSymbol n`
--   </pre>
--   
--   This is essentially a singleton for <a>Symbol</a>, and stands in for
--   the <i>singletons</i> <a>SSymbol</a> and <a>Sing</a> types.
data SSymbol n
SSymbol :: SSymbol n

-- | This type represents unknown type-level symbols.
data SomeSymbol

-- | A useful pattern synonym for matching on a <a>SomeSymbol</a> as if it
--   contained an <tt><a>SSymbol</a> n</tt>, and not a <tt><a>Proxy</a>
--   n</tt> as it exists in <a>GHC.TypeLits</a>.
--   
--   A layer of compatibility letting us use the original <a>SomeSymbol</a>
--   type in a way that works well with <a>SSymbol</a>.
--   
--   This stands in for the <i>singletons</i> <a>SomeSing</a> constructor.
pattern SomeSymbol_ :: SSymbol n -> SomeSymbol

-- | A useful pattern synonym for matching on a <a>String</a> as if it
--   "were" a <a>SSymbol</a>:
--   
--   <pre>
--   myFunc :: String -&gt; Bool
--   myFunc (FromSSymbol x) = ...  -- x is `SSymbol n`, with <tt>n</tt> coming from the input
--   </pre>
--   
--   It can be used as a function, as well, to convert an
--   <tt><a>SSymbol</a> n</tt> back into the <a>String</a> that it
--   represents.
--   
--   This stands in for the <i>singletons</i> <a>FromSing</a> pattern
--   synonym, except it matches on a <a>String</a> instead of a
--   <a>Text</a>.
pattern FromSSymbol :: SSymbol n -> String

-- | Convert ("reflect") an <a>SSymbol</a> back into the <a>String</a> it
--   represents.
--   
--   This stands in the <i>singletons</i> <a>fromSing</a> function, except
--   it returns a <a>String</a> instead of <a>Text</a>.
fromSSymbol :: SSymbol n -> String

-- | Given an <tt><a>SSymbol</a> n</tt> and a value that would require a
--   <tt><a>KnownSymbol</a> n</tt> instance, create that value.
--   
--   This stands in for the function of the same name from
--   <a>Data.Singletons.TypeLits</a>.
withKnownSymbol :: SSymbol n -> (KnownSymbol n => r) -> r

-- | Promote ("reify") a <a>String</a> to an <tt><a>SSymbol</a> n</tt>, by
--   providing a continuation that would handle it in a way that is
--   polymorphic over all possible <tt>n</tt>.
--   
--   This stands in the <i>singletons</i> <a>withSomeSing</a> function,
--   except it takes a <a>String</a> instead of <a>Text</a>.
withSomeSymbol :: String -> (forall n. SSymbol n -> r) -> r

-- | Promote ("reify") a <a>String</a> to an <tt><a>SSymbol</a> n</tt>
--   existentially hidden inside a <a>SomeNat</a>. To use it, pattern match
--   using <a>SomeSymbol_</a>.
--   
--   This stands in the <i>singletons</i> <a>toSomeSing</a> function,
--   except it takes a <a>String</a> instead of <a>Text</a>.
toSomeSymbol :: String -> SomeSymbol
instance GHC.Classes.Eq (GHC.TypeLits.Witnesses.SNat n)
instance GHC.Classes.Ord (GHC.TypeLits.Witnesses.SNat n)
instance GHC.Classes.Eq (GHC.TypeLits.Witnesses.SSymbol n)
instance GHC.Classes.Ord (GHC.TypeLits.Witnesses.SSymbol n)
instance GHC.Show.Show (GHC.TypeLits.Witnesses.SSymbol n)
instance Data.GADT.Show.GShow GHC.TypeLits.Witnesses.SSymbol
instance Data.Type.Equality.TestEquality GHC.TypeLits.Witnesses.SSymbol
instance Data.GADT.Compare.GEq GHC.TypeLits.Witnesses.SSymbol
instance Data.GADT.Compare.GCompare GHC.TypeLits.Witnesses.SSymbol
instance GHC.Show.Show (GHC.TypeLits.Witnesses.SNat n)
instance Data.GADT.Show.GShow GHC.TypeLits.Witnesses.SNat
instance Data.Type.Equality.TestEquality GHC.TypeLits.Witnesses.SNat
instance Data.GADT.Compare.GEq GHC.TypeLits.Witnesses.SNat
instance Data.GADT.Compare.GCompare GHC.TypeLits.Witnesses.SNat
